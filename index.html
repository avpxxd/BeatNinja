<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BeatNinja</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .hud-text {
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.7);
        }
        .menu-card {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        .life-segment {
            transition: background-color 0.3s ease;
        }
        @keyframes shake-horizontal {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-6px); }
            20%, 40%, 60%, 80% { transform: translateX(6px); }
        }
        .shake {
            animation: shake-horizontal 0.5s ease-in-out;
        }
        @keyframes bounce-and-shake {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.4) rotate(0deg); }
            50% { transform: scale(1.1) rotate(-8deg); }
            75% { transform: scale(1.2) rotate(8deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        .multiplier-bounce {
            animation: bounce-and-shake 0.6s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white select-none">

    <div id="game-container" class="relative w-full h-screen overflow-hidden">
        <canvas id="gameCanvas"></canvas>

        <div id="hud" class="absolute top-0 left-0 right-0 p-4 sm:p-6 flex flex-col items-center pointer-events-none hidden">
            <div id="lifeBarContainer" class="w-full max-w-xs md:max-w-sm h-3 flex gap-1.5 mb-3">
                <div class="life-segment h-full w-1/4 rounded bg-gray-600"></div>
                <div class="life-segment h-full w-1/4 rounded bg-gray-600"></div>
                <div class="life-segment h-full w-1/4 rounded bg-gray-600"></div>
                <div class="life-segment h-full w-1/4 rounded bg-gray-600"></div>
            </div>

            <div class="w-full flex justify-between items-center text-3xl sm:text-4xl font-bold">
                <div class="w-1/3 text-left">
                    <button id="pauseButton" class="w-12 h-12 rounded-full bg-gray-800 bg-opacity-50 flex items-center justify-center transition-transform transform hover:scale-110 pointer-events-auto">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    </button>
                </div>
                <div class="w-1/3 text-center hud-text">
                    <span id="score">0</span>
                </div>
                <div class="w-1/3 text-right hud-text">
                     <span id="multiplier" class="text-2xl sm:text-3xl font-bold transition-colors duration-300"></span>
                </div>
            </div>
        </div>

        <div id="startMenu" class="absolute inset-0 flex justify-center items-center">
            <div class="menu-card bg-gray-800 bg-opacity-50 p-8 sm:p-12 text-center rounded-2xl w-11/12 max-w-2xl">
                <h1 class="text-5xl sm:text-7xl font-extrabold mb-4 text-cyan-400">BeatNinja</h1>
                <p class="text-lg sm:text-xl mb-4 text-gray-300">Slice the blocks in the correct direction before they reach the bottom.</p>
                <p class="text-lg sm:text-xl mb-4 text-gray-300">Avoid Bombs, (Yellow) and Collect lives. (Pink)</p>
                <p class="text-lg sm:text-xl mb-4 text-gray-300">Get combos to increase your score multiplier.</p>
                <p class="text-lg sm:text-xl mb-8 text-gray-300">Best Played On Devices With A Touchscreen.</p>
                <button id="startButton" class="bg-cyan-500 hover:bg-cyan-400 text-gray-900 font-bold py-3 px-8 rounded-full text-2xl transition-transform transform hover:scale-105 shadow-lg">
                    Start Game
                </button>
            </div>
        </div>

        <div id="pauseMenu" class="absolute inset-0 flex-col justify-center items-center hidden bg-black bg-opacity-50">
            <div class="menu-card bg-gray-800 bg-opacity-50 p-8 sm:p-12 text-center rounded-2xl w-11/12 max-w-lg">
                <h1 class="text-5xl sm:text-7xl font-extrabold mb-8 text-cyan-400">Paused</h1>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button id="resumeButton" class="bg-cyan-500 hover:bg-cyan-400 text-gray-900 font-bold py-3 px-8 rounded-full text-2xl transition-transform transform hover:scale-105 shadow-lg">
                        Resume
                    </button>
                    <button id="restartFromPauseButton" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-8 rounded-full text-2xl transition-transform transform hover:scale-105 shadow-lg">
                        Restart
                    </button>
                </div>
            </div>
        </div>
        
        <div id="gameOverMenu" class="absolute inset-0 flex justify-center items-center hidden">
            <div class="menu-card bg-gray-800 bg-opacity-50 p-8 sm:p-12 text-center rounded-2xl w-11/12 max-w-lg">
                <h1 class="text-5xl sm:text-7xl font-extrabold mb-2 text-red-500">Game Over</h1>
                <p class="text-2xl sm:text-3xl mb-4 text-gray-200">Final Score: <span id="finalScore">0</span></p>
                <p class="text-lg sm:text-xl mb-8 text-gray-300">High Score: <span id="highScoreMenu">0</span></p>
                <button id="restartButton" class="bg-cyan-500 hover:bg-cyan-400 text-gray-900 font-bold py-3 px-8 rounded-full text-2xl transition-transform transform hover:scale-105 shadow-lg">
                    Play Again
                </button>
            </div>
        </div>
    </div>
    
    <!-- THIS IS THE LINE TO CHANGE FOR YOUR OWN MUSIC -->
    <audio id="backgroundMusic" loop src="http://www.bensound.com/bensound-music/bensound-onrepeat.mp3"></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');

        const hud = document.getElementById('hud');
        const scoreEl = document.getElementById('score');
        const lifeBarContainer = document.getElementById('lifeBarContainer');
        const lifeSegments = document.querySelectorAll('#lifeBarContainer .life-segment');
        const multiplierEl = document.getElementById('multiplier');
        const startMenu = document.getElementById('startMenu');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const finalScoreEl = document.getElementById('finalScore');
        const highScoreMenuEl = document.getElementById('highScoreMenu');
        
        const pauseButton = document.getElementById('pauseButton');
        const pauseMenu = document.getElementById('pauseMenu');
        const resumeButton = document.getElementById('resumeButton');
        const restartFromPauseButton = document.getElementById('restartFromPauseButton');
        const backgroundMusic = document.getElementById('backgroundMusic'); // Music element

        let score = 0, highScore = localStorage.getItem('sliceFusionHighScore') || 0;
        let lives = 3, maxLives = 4, startingLives = 3;
        let gameState = 'menu';

        let multiplier = 1, comboCounter = 0;
        const maxMultiplier = 8, comboThreshold = 20;

        let blocks = [], particles = [], swipeTrail = [];
        let shakeDuration = 0, shakeMagnitude = 0, shakeStartTime = 0;
        let isSwiping = false, lastSpawnTime = 0, spawnInterval = 1500, baseSpeed = 2;
        let pausedTime = 0;

        const BLOCK_SIZE = 80;
        const DIRECTIONS = ['up', 'down', 'left', 'right'];
        const DIRECTION_ANGLES = { up: -Math.PI / 2, down: Math.PI / 2, left: Math.PI, right: 0 };
        const COLORS = ['#ef4444', '#3b82f6'];

        function resizeCanvas() { canvas.width = gameContainer.clientWidth; canvas.height = gameContainer.clientHeight; }

        class Block {
            constructor(x, y, type) { this.x = x; this.y = y; this.size = BLOCK_SIZE; this.type = type; this.speed = baseSpeed + Math.random() * 1.5; this.direction = this.type === 'normal' ? DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)] : null; this.sliced = false; this.angle = Math.random() * 0.2 - 0.1; switch (this.type) { case 'normal': this.color = COLORS[Math.floor(Math.random() * COLORS.length)]; break; case 'bomb': this.color = '#facc15'; break; case 'heart': this.color = '#f472b6'; break; } }
            update() { this.y += this.speed; }
            draw() { ctx.save(); ctx.translate(this.x + this.size / 2, this.y + this.size / 2); ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.strokeStyle = (this.type === 'bomb' || this.type === 'heart') ? '#4b5563' : '#ffffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.roundRect(-this.size / 2, -this.size / 2, this.size, this.size, 12); ctx.fill(); ctx.stroke(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; if (this.type === 'normal') { ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.beginPath(); const arrowSize = this.size * 0.3; switch (this.direction) { case 'up': ctx.moveTo(0, -arrowSize); ctx.lineTo(arrowSize, 0); ctx.lineTo(-arrowSize, 0); break; case 'down': ctx.moveTo(0, arrowSize); ctx.lineTo(arrowSize, 0); ctx.lineTo(-arrowSize, 0); break; case 'left': ctx.moveTo(-arrowSize, 0); ctx.lineTo(0, -arrowSize); ctx.lineTo(0, arrowSize); break; case 'right': ctx.moveTo(arrowSize, 0); ctx.lineTo(0, -arrowSize); ctx.lineTo(0, arrowSize); break; } ctx.closePath(); ctx.fill(); } else if (this.type === 'bomb') { ctx.fillStyle = '#4b5563'; ctx.beginPath(); ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2); ctx.fill(); } else if (this.type === 'heart') { ctx.font = `${this.size * 0.6}px Poppins`; ctx.fillStyle = '#ffffff'; ctx.fillText('❤️', 0, 0); } ctx.restore(); }
        }

        class Particle {
            constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.size = Math.random() * 10 + 5; this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8; this.alpha = 1; this.gravity = 0.2; }
            update() { this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.alpha -= 0.02; }
            draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        }

        function spawnBlock() { const x = Math.random() * (canvas.width - BLOCK_SIZE); const y = -BLOCK_SIZE; const rand = Math.random(); let type; if (rand < 0.02) { type = 'heart'; } else if (rand < 0.10) { type = 'bomb'; } else { type = 'normal'; } blocks.push(new Block(x, y, type)); }
        function createParticles(x, y, color) { for (let i = 0; i < 20; i++) particles.push(new Particle(x, y, color)); }
        function triggerScreenShake(magnitude, duration) { shakeMagnitude = magnitude; shakeDuration = duration; shakeStartTime = Date.now(); }

        function update() {
            if (gameState !== 'playing') return;
            if (Date.now() - lastSpawnTime > spawnInterval) { spawnBlock(); lastSpawnTime = Date.now(); if (spawnInterval > 350) spawnInterval *= 0.992; if (baseSpeed < 10) baseSpeed += 0.018; }
            for (let i = blocks.length - 1; i >= 0; i--) { const block = blocks[i]; block.speed = baseSpeed + (block.speed - Math.floor(block.speed)); block.update(); if (block.y > canvas.height) { if (block.type === 'normal' && !block.sliced) { lives--; updateLivesDisplay(); comboCounter = 0; if (multiplier > 1) { multiplier = 1; updateMultiplierDisplay(); } createParticles(block.x + block.size/2, canvas.height - 20, '#9ca3af'); if (lives <= 0) { gameOver(); return; } } blocks.splice(i, 1); } }
            particles.forEach((p, i) => { p.update(); if (p.alpha <= 0) particles.splice(i, 1); });
            if (swipeTrail.length > 20) swipeTrail.shift();
        }

        function draw() {
            update();
            ctx.save();
            if (shakeDuration > 0 && Date.now() - shakeStartTime < shakeDuration) { const p = (Date.now() - shakeStartTime) / shakeDuration; const m = shakeMagnitude * (1 - p); const x = (Math.random() - 0.5) * m * 2; const y = (Math.random() - 0.5) * m * 2; ctx.translate(x, y); } else { shakeDuration = 0; }
            ctx.fillStyle = '#111827'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (gameState !== 'menu') { blocks.forEach(b => b.draw()); particles.forEach(p => p.draw()); if (swipeTrail.length > 1) { ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; for(let i = 1; i < swipeTrail.length; i++) { ctx.lineWidth = i / swipeTrail.length * 15; ctx.beginPath(); ctx.moveTo(swipeTrail[i-1].x, swipeTrail[i-1].y); ctx.lineTo(swipeTrail[i].x, swipeTrail[i].y); ctx.stroke(); } } }
            ctx.restore();
            requestAnimationFrame(draw);
        }

        function addScore(points) { score += points; scoreEl.textContent = score; }
        
        function updateLivesDisplay() { lifeSegments.forEach((s, i) => { if (i < lives) { s.classList.remove('bg-gray-600'); s.classList.add('bg-cyan-400'); } else { s.classList.remove('bg-cyan-400'); s.classList.add('bg-gray-600'); } }); }

        function updateMultiplierDisplay() { multiplierEl.textContent = `x${multiplier}`; if (multiplier > 1) { multiplierEl.classList.remove('text-gray-500'); multiplierEl.classList.add('text-yellow-400'); } else { multiplierEl.classList.remove('text-yellow-400'); multiplierEl.classList.add('text-gray-500'); } }

        function checkSlice(x, y) {
            if (swipeTrail.length < 2 || gameState !== 'playing') return;
            for (let i = blocks.length - 1; i >= 0; i--) {
                const block = blocks[i];
                if (block.sliced) continue;
                if (x > block.x && x < block.x + block.size && y > block.y && y < block.y + block.size) {
                    if (block.type === 'bomb') { lives--; updateLivesDisplay(); comboCounter = 0; if (multiplier > 1) { multiplier = 1; updateMultiplierDisplay(); } block.sliced = true; triggerScreenShake(15, 200); createParticles(block.x + block.size / 2, block.y + block.size / 2, '#ef4444'); setTimeout(() => { const index = blocks.indexOf(block); if (index > -1) blocks.splice(index, 1); }, 100); if (lives <= 0) { gameOver(); } return; }
                    if (block.type === 'heart') { if (lives >= maxLives) { lifeBarContainer.classList.add('shake'); setTimeout(() => lifeBarContainer.classList.remove('shake'), 500); } else { lives++; updateLivesDisplay(); } block.sliced = true; createParticles(block.x + block.size / 2, block.y + block.size / 2, block.color); setTimeout(() => { const index = blocks.indexOf(block); if (index > -1) blocks.splice(index, 1); }, 100); return; }
                    const p1 = swipeTrail[swipeTrail.length - 2], p2 = swipeTrail[swipeTrail.length - 1]; const dx = p2.x - p1.x, dy = p2.y - p1.y; if (Math.hypot(dx, dy) < 10) continue; const angle = Math.atan2(dy, dx); const requiredAngle = DIRECTION_ANGLES[block.direction]; const angleDiff = Math.abs(angle - requiredAngle); const tolerance = Math.PI / 2.5;
                    if (Math.min(angleDiff, Math.abs(angleDiff - 2 * Math.PI)) < tolerance) { block.sliced = true; addScore(10 * multiplier); comboCounter++; if (comboCounter % comboThreshold === 0 && multiplier < maxMultiplier) { multiplier++; multiplierEl.classList.add('multiplier-bounce'); setTimeout(() => multiplierEl.classList.remove('multiplier-bounce'), 600); } updateMultiplierDisplay(); createParticles(block.x + block.size / 2, block.y + block.size / 2, block.color); setTimeout(() => { const index = blocks.indexOf(block); if (index > -1) blocks.splice(index, 1); }, 100); }
                }
            }
        }
        
        function getEventCoords(e) { let x, y; if (e.touches && e.touches.length > 0) { x = e.touches[0].clientX; y = e.touches[0].clientY; } else { x = e.clientX; y = e.clientY; } return { x, y }; }
        function handleStartSwipe(e) { if (gameState !== 'playing') return; isSwiping = true; swipeTrail = [getEventCoords(e)]; }
        function handleMoveSwipe(e) { if (isSwiping && gameState === 'playing') { e.preventDefault(); const { x, y } = getEventCoords(e); swipeTrail.push({ x, y }); checkSlice(x, y); } }
        function handleEndSwipe() { isSwiping = false; swipeTrail = []; }
        
        function startGame() { 
            score = 0; lives = startingLives; blocks = []; particles = []; 
            multiplier = 1; comboCounter = 0;
            scoreEl.textContent = score; 
            updateLivesDisplay(); 
            updateMultiplierDisplay();
            baseSpeed = canvas.height / 400; spawnInterval = 1500; 
            lastSpawnTime = Date.now(); 
            gameState = 'playing'; 
            startMenu.classList.add('hidden'); 
            gameOverMenu.classList.add('hidden');
            pauseMenu.classList.add('hidden');
            pauseMenu.classList.remove('flex');
            hud.classList.remove('hidden'); 
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(error => console.log("User needs to interact with the document first to play audio."));
        }

        function gameOver() { 
            if (gameState === 'gameOver') return; 
            gameState = 'gameOver'; 
            finalScoreEl.textContent = score; 
            if (score > highScore) { highScore = score; localStorage.setItem('sliceFusionHighScore', highScore); } 
            highScoreMenuEl.textContent = highScore; 
            hud.classList.add('hidden'); 
            gameOverMenu.classList.remove('hidden'); 
            backgroundMusic.pause();
        }
        
        function pauseGame() {
            if (gameState !== 'playing') return;
            pausedTime = Date.now();
            gameState = 'paused';
            hud.classList.add('hidden');
            pauseMenu.classList.remove('hidden');
            pauseMenu.classList.add('flex');
            backgroundMusic.pause();
        }

        function resumeGame() {
            if (gameState !== 'paused') return;
            const elapsed = Date.now() - pausedTime;
            lastSpawnTime += elapsed;
            gameState = 'playing';
            hud.classList.remove('hidden');
            pauseMenu.classList.add('hidden');
            pauseMenu.classList.remove('flex');
            backgroundMusic.play().catch(error => console.log("Audio play failed on resume:", error));
        }

        window.addEventListener('resize', resizeCanvas);
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        pauseButton.addEventListener('click', pauseGame);
        resumeButton.addEventListener('click', resumeGame);
        restartFromPauseButton.addEventListener('click', startGame);
        
        canvas.addEventListener('mousedown', handleStartSwipe); canvas.addEventListener('mousemove', handleMoveSwipe); canvas.addEventListener('mouseup', handleEndSwipe); canvas.addEventListener('mouseleave', handleEndSwipe);
        canvas.addEventListener('touchstart', handleStartSwipe, { passive: false }); canvas.addEventListener('touchmove', handleMoveSwipe, { passive: false }); canvas.addEventListener('touchend', handleEndSwipe); canvas.addEventListener('touchcancel', handleEndSwipe);
        
        resizeCanvas();
        highScoreMenuEl.textContent = highScore;
        requestAnimationFrame(draw);
    </script>
</body>
</html>
